







NEW EBNF:
# Expression
atom   = INT
	   | NAME
       | '(' expression ')'
funcall   = {expression ','} [expression] ')'
postfix   = atom [('[' expression ']' | '(' funcall)]
prefix    = [('-'|'!')] prefix | postfix
bool_ops  = prefix [('=='|'!='|'<='|'>='|'<'|'>') prefix]
mul_ops   = bool_ops [('*'|'/'|'%') bool_ops]
add_ops   = add_ops [('+'|'-') add_ops]
expression = add_ops

# Lone Expression Statement
lone_expr = expression ';'

# Assignment
assignment = 'set' expression '=' expression ';'

# Declaration
declaration = 'let' NAME '=' expression ';'

# If/Elif/Else
if_statement = 'if' expression scope {'elif' expression scope} ['else' scope]

# While
while_statement = 'while' expression scope

# Scope
statement = lone_expr
		  | assignment
		  | declaration
		  | if_statement
		  | while_statement
		  | scope
scope = '{' {statement} '}'

# Function declaration
func_decl = 'func' NAME arg_list scope

file = {func_decl}


--------------



VM Design:

OPERATOR STACK: The stack operators get applied to
CALL STACK: The stack that stack frames get pushed to, containing function variables

Compiling a function call:
 # function(5, 10)
The current SP is saved, and the arguments are pushed to the call stack
 # SP = 15 -> TV
 # [..., 5, 10]
 # SP = 17 
The function is looked up in a table to determine it's
declarations. These are pushed onto the call stack in order.
 # func function(a, b) {
 #     let c = 1;
 #     let d = 2;
 # }
 # [..., 5, 10, DEADBEEF, DEADBEEF]
Each statement in the body is compiled. When a variable is encountered
in an expression, a LOAD instruction loads the variable from a
callstack offset into the operator stack.

--------------

EBNF:

atom = LITERAL | NAME | '(' expression ')'
unary = [-] atom
factor = unary {('*' | '/') unary}
expression = factor {('+' | '-') factor}
let = 'let' NAME '=' expression
while = 'while' expression '{' {statement} '}'
if = 'if' expression '{' {statement} '}' ['else' '{' {statement} '}']
print = 'print' expression
statement = (let|while|if|print) ';'
